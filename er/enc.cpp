// Copyright (c) Open Enclave SDK contributors.
// Licensed under the MIT License.

#include <stdio.h>
#include <iostream>
#include <cstdint>
#include <algorithm>
#include <cstring>
#include <sys/time.h> 
#include "include/oht/lib.h"
#include "include/oht/crypto.h"
#include "er_t.h"
#include <map>
// #include <utility>
// #include <chrono>
// #include <thread>
#include <pthread.h>

// Include the trusted helloworld header that is generated
// during the build. This file is generated by calling the
// sdk tool oeedger8r against the helloworld.edl file.
#include "er_t.h"

// This is the function that the host calls. It prints
// a message in the enclave before calling back out to
// the host to print a message from there too.


#include <cstdint>
#include <cstddef>

static std::vector<uint8_t> kSymmKey(16, 'a');
static std::vector<uint8_t> kSymmIv(12, 0);

namespace boomerang {

constexpr size_t kMacSize = 16;
constexpr size_t kContentSize = 256;


struct PktHead {
  uint64_t signal;
  bool ___read_write;
  bool is_dummy;
  bool ___is_exceed;
  uint8_t ___enode_id;
};

struct Pkt {
  PktHead head;
  uint8_t content[kContentSize]{};
  uint8_t mac[kMacSize]{};
};

constexpr size_t kPktSize = sizeof(Pkt); // 285

template <size_t Ksize, size_t Vsize>
oht::Elem<Ksize, Vsize> pkt_to_elem(const Pkt *pkt) {
  oht::Elem<Ksize, Vsize> elem{};
  elem.tag = oht::obl::OblChoose(pkt->head.is_dummy, oht::kTagDummy, uint32_t(0));
  std::memcpy(elem.key, &pkt->head.signal, Ksize);
  std::memcpy(elem.val, pkt->content, Vsize);
  return elem;
}

template <size_t Ksize, size_t Vsize>
oht::Elem<Ksize, Vsize> pkt_buf_to_elem(uint8_t *pkt_start) {
//   assert(aes128_dec(pkt_start, kPktSize - kMacSize, nullptr, kSymmKey.data(), kSymmIv.data()) == 0);
  return pkt_to_elem<Ksize, Vsize>(reinterpret_cast<const Pkt *>(pkt_start));
}

template <size_t Ksize, size_t Vsize>
oht::Elem<Ksize, Vsize> pkt_const_buf_to_elem(const uint8_t *pkt_start, std::vector<uint8_t> &buf) {
  std::memcpy(buf.data(), pkt_start, kPktSize);
  return pkt_buf_to_elem<Ksize, Vsize>(buf.data());
}

template <size_t Vsize>
void val_elem_to_pkt(uint8_t *pkt_start, const uint8_t *val) {
  auto pkt = reinterpret_cast<Pkt *>(pkt_start);
  std::memcpy(pkt->content, val, Vsize);
//   assert(aes128_enc(pkt_start, kPktSize - kMacSize, pkt->mac, kSymmKey.data(), kSymmIv.data()) == 0);
}



// head 13

}  // namespace boomerang

struct Config {
    size_t sizeBoomerangPkt = 285;
    size_t sizeBoomerangPktHead = 13;
    size_t sizeBoomerangPktMac = 16;
    size_t sizeBoomerangPktContent = 256;

    size_t numUser = 0;
    size_t numEnode = 0;
    size_t numBnode = 0;
    size_t numBatch = 4502;

    size_t kKsize = 8;
    size_t kVsize = 8;
    size_t sizeElem = 272;

    double kLambda = 128;
    double kEpsilon = 0.75;
    // double kLogLambdaPowEpsilon = std::pow(std::log(kLambda), kEpsilon);
    double kLogLambdaPowEpsilon = 3.26921;
    // size_t kBound = std::exp(3 * kLogLambdaPowEpsilon);
    size_t kBound = 18171;

    size_t numBatchSmall = 4502;
    size_t kZSmall = 25;
    // size_t kBSmall = std::ceil(uint32_t(5 * batch_num / kZ));
    size_t kBSmall = 900;
    size_t sizeOhtSmall = 6120000; // 6M

    size_t mergeTrager = 10;

    size_t numBatchBig = 45020;
    size_t kZBig = 17;
    // size_t kBSmall = std::ceil(uint32_t(5 * batch_num / kZ));
    size_t kBBig = 13241;
    size_t sizeOhtBig = 122452768; // 122M

};



// Read List class define 
template <size_t Ksize, size_t Vsize>
class ReadList {
public:
    ReadList() : head(nullptr), smalltail(nullptr), tail(nullptr) {}

    // 插入到 BigOht 区域末尾
    void insertIntoBigOht(oht::OhtHead* oht) {
        if (!head) {
            head = oht;
            tail = oht;
        } else {
            tail->next = oht;
            oht->pre = tail;
            tail = oht;
        }
        id_map[oht->id] = oht;
    }

    // 插入到 SmallOht 区域末尾
    void insertIntoSmallOht(oht::OhtHead* oht) {
        if (!head) {
            head = oht;
            tail = oht;
            smalltail = oht;
        } else {
            oht->next = smalltail->next;
            if (smalltail->next) {
                smalltail->next->pre = oht;
            }
            smalltail->next = oht;
            oht->pre = smalltail;
            if (smalltail == tail) {
                tail = oht;
            }
            smalltail = oht;
        }
        id_map[oht->id] = oht;
    }

    // 删除指定 id 的 OhtHead
    oht::Oht<8, 256>* deleteById(size_t id) {
        auto it = id_map.find(id);
        oht::Oht<8, 256>* res;
        if (it != id_map.end()) {
            oht::OhtHead* oht = it->second;
            
            if (oht->pre) {
                oht->pre->next = oht->next;
            }
            if (oht->next) {
                oht->next->pre = oht->pre;
            }
            if (head == oht) {
                head = oht->next;
            }
            if (tail == oht) {
                tail = oht->pre;
            }
            if (smalltail == oht) {
                smalltail = oht->pre;
            }
            id_map.erase(it);
            res = oht->oht_p;
            delete oht;
        }
        return res;
    }

    size_t nextSmall() {
        if (!smalltail) {
            return 0;
        } else {
            return smalltail->id + 1;
        }
    }

    size_t nextBig() {
        if (!tail) {
            return 0;
        } else {
            return tail->id + 1;
        }
    }

    // 迭代器的 begin 函数
    oht::OhtHead* begin() const {
        return head;
    }

    // 迭代器的 end 函数
    oht::OhtHead* end() const {
        return nullptr; // 结束迭代的标志，通常为 nullptr
    }

private:
    oht::OhtHead* head;       // 队列头部指针
    oht::OhtHead* smalltail;  // BigOht区域开始位置前一个位置，也可以理解为small区域结尾
    oht::OhtHead* tail;       // 队列尾部指针
    std::map<size_t, oht::OhtHead*> id_map;  // 方便删除用的
};

// template<size_t Ksize, size_t Vsize>
// class EnclaveRead {
// public:
//     EnclaveRead() : read_list(ReadList<8,256>()), config(Config()) {
//         configUserNum = 0;
//         configEnodeNum = 0;
//         configBnodeNum =0;
//         configPktSize = 285;
//         configBatchNum = 4502;
//         configBatchSize = configItemSize * configItemSize;
//         configPktSize = 496;
//         configSmallSize = 688;
//         configBigOhtSize = 6880;
//     }
//     /* wyh:
//     readBatch
//     介绍：
//         readBatch是read data到来时 host 直接发给er的部分，用于读取一个batch中所有提到的read请求
//     输入：
//         dataBatch（兼作输出）：到来的数据格式为加密后的pkt list，由于输出结果只是更改了pkt list中pkt的一些成员，所以是在原地进行替换的
//     输出：
//         见输入
//     */
//     void readBatch(uint8_t *dataBatch, size_t dataBatchSize) {
//         // 解密，转换为elems
//         std::vector<oht::Elem<8,256>> elems{};
//         elems.reserve(configBatchNum);
//         std::vector<uint8_t> pkt_dec_buf{};
//         pkt_dec_buf.reserve(configPktSize);
//         for (auto pkt_start = dataBatch; pkt_start + configPktSize <= dataBatch + dataBatchSize; pkt_start += configPktSize) {
//             elems.push_back(pkt_const_buf_to_elem<8,256>(pkt_start, pkt_dec_buf));
//         }
//         // 对每个elem调用
//         for (auto& elem : elems) {
//             readSingle(elem)
//         }
//         // 加密，转换为uint8_t
//         for (auto i = 0; i < elems.size(); i++) {
//             auto pkt_start = dataBatch + configPktSize * i;
//             val_elem_to_pkt<256>(pkt_start, elems[i].val);
//         }
//         // 返回
//         return;
//     }
    
//     /* wyh:
//     writeBatch
//     介绍：
//         writeBatch 是write data到来时host直接发给er的部分，用于将一个batch转换为一个小oht
//     输入：
//         dataBatch：host接收到的write batch原始数据，是加密后的boomerang pkt数据，需要转换为elems后进行后续处理
//     输出：
//         indexesInEnclave：用于指示这一batch对应的oht是哪些，因为小oht可能会有堆积所以不能是直接把所有的都合并了。
//         （这一块还在考虑，感觉最好的方案是在host中保持一个map，用于指示哪个batch对应哪些小oht，这样merage的时候就可以比较简单了。需要注意的是实际上只有exchangeOht 中是需要index数据的，ew的merage步骤并不需要这个数据，因此由host完成可能是比较好的选择（但会有安全问题））
//         （indexesInEnclave直接使用from、to 两个进行算了，这会强依赖于单线程的假设，因为插入ReadList的顺序必须是一定的，两个batch之间不能穿插）
//     */
//     void writeBatch(const uint8_t *dataBatch, size_t dataBatchSize, size_t *index) {
//         // 解密，转换为elems
//         std::vector<Elem<8,256>> elems{};
//         elems.reserve(configBatchNum);
//         std::vector<uint8_t> pkt_dec_buf{};
//         pkt_dec_buf.reserve(configPktSize);
//         for (auto pkt_start = dataBatch; pkt_start + configPktSize <= dataCache + dataBatchSize; pkt_start += configPktSize) {
//             elems.push_back(pkt_const_buf_to_elem<8,256>(pkt_start, pkt_dec_buf));
//         }
//         // oht prepare build
//         // 分配到堆上，避免被删除，注意自己删除
//         auto ohtP = new oht::Oht<8,256>();
//         ohtWrite(ohtP, std::move(elems), kPrfKey, kJobs);
//         // 构造oht head 放进read_list
//         auto ohtHead = new oht::OhtHead<8,256>;
//         // 注意，delete在exchange 和 退出函数中
//         ohtHead->id = read_list.nextSmall()
//         ohtHead->oht_p = ohtP;
//         ohtHead->size = configSmallSize;
//         ohtHead->is_in = true;
//         read_list.insertIntoSmallOht(OhtHead);
//         // 设置oht index
//         *index = ohtHead->id;
//         // 返回
//         return;
//     }
    
//     /* wyh:
//     exchangeOht
//     介绍：
//         是write过程中host接收到ew merage结果后调用er的过程；实际进行的是将指示的几个ohtHead删除，然后在队尾插入一个bigOhtHea
//     输入：
//         indexes: 用于指示替换哪些小oht
//         （在纠结是否保留全部oht（实际上也就10个），还是只有是开始结尾两个（这样强依赖于单线程））
//         bigOhtHead：用于替换掉readlist中的
//     输出：
//         无，不需要
//     */
//     // void exchangeOht(size_t indexFrom, size_t indexTo, uint8_t *bigOhtHead, size_t bigOhtHeadSize) {
//     //     // 解密bigOhtHead
//     //     // TODO
//     //     std::vector<Elem<kKsize, kVsize>> elems{};
//     //     elems.reserve(configBatchNum);
//     //     std::vector<uint8_t> pkt_dec_buf{};
//     //     pkt_dec_buf.reserve(configPktSize);
//     //     for (auto pkt_start = dataBatch; pkt_start + configPktSize <= dataCache + dataBatchSize; pkt_start += configPktSize) {
//     //         elems.push_back(pkt_const_buf_to_elem<8,256>(pkt_start, pkt_dec_buf));
//     //     }
//     //     // 从indexFrom到indexTo 遍历删除（或许可以写个函数简单点）
//     //     for (size_t i = indexFrom; i < indexTo; i++) {
//     //         auto ohtInHeap = read_list.deleteById(i);
//     //         delete ohtInHeap;
//     //     }
//     //     // 把bigOhtHead岔道bigOht区域后面
//     //     // void insertIntoBigOht(OhtHead* oht)
//     //     auto bigOht = new OhtHead();
//     //     memcpy(bigOht, bigOhtHead, bigOhtHeadSize);
//     //     read_list.insertIntoBigOht(bigOht);
//     //     // 返回
//     //     return;
//     // }

// private:
//     /* wyh:
//     readSingle
//     介绍：
//         readSingle是readBatch的辅助函数，是实际进行读的部分
//     输入：
//         elem（兼作输出）单独一个elem，直接对所有read list中的oht调用lookup就行了
//     输出：
//         见输入
//     */
    

//     void ohtWrite(oht::Oht<8,256> *oht, std::vector<oht::Elem<8,256>> &&elems, const std::vector<uint8_t> &prf_key, unsigned jobs) {
//         for (auto &&elem : elems) {
//             oht->prepare(std::move(elem));
//         }
//         oht->build(prf_key, jobs);
//         // todo 这个key到底是用来干啥的 fuck！！直接设置成全局一致了
//         // ohtHead.prf_key = prf_key;
//     }

//     std::vector<oht::Oht<8,256>> oht_in;
//     ReadList<8,256> read_list;
//     std::vector<uint8_t> kPrfKey{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

//     // from config
//     Config config;
//     size_t configBatchSize;
//     size_t configItemSize;
//     size_t configBatchNum;
//     size_t configPktSize;
//     size_t configSmallSize;
//     size_t configBigOhtSize;
//     size_t configUserNum;
//     size_t configEnodeNum;
//     size_t configBnodeNum;
// };
long long getTime() {
    struct timeval tv;
    gettimeofday(&tv, NULL);
    return (long long)tv.tv_sec * 1000 + tv.tv_usec / 1000;
}
void enclave_helloworld2()
{
    // Print a message from the enclave. Note that this
    // does not directly call fprintf, but calls into the
    // host and calls fprintf from there. This is because
    // the fprintf function is not part of the enclave
    // as it requires support from the kernel.
    // fprintf(stdout, "Hello world from the enclave\n");
    // for time
    //

    // // only big
    size_t elems_num_batch = 4502;
    size_t merage_trager = 10;
    size_t read_times = 1000;
    size_t oht_num = 1024;

    size_t small_z = 25;
    size_t small_b = std::ceil(uint32_t(5* elems_num_batch / small_z));

    size_t big_z = 17;
    size_t big_b = std::ceil(uint32_t(5* elems_num_batch * merage_trager / big_z));

    bool test_small = false;
    ReadList<8,256> read_list;
    oht::OhtHead *head;
    oht::Elem<8, 256> only_elem;
    only_elem.tag = uint32_t(7);
    uint8_t array8[8];
    uint8_t array256[256];
    for (int i = 0; i < 8; ++i) {
        array8[i] = 8;
    }
    for (int i = 0; i < 8; ++i) {
        array256[i] = 256;
    }
    std::memcpy(only_elem.key, array8, 8);
    std::memcpy(only_elem.val, array256, 256);
    std::vector<uint8_t> kPrfKey{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    // std::vector<size_t> vTest{1,2,3};
    // vTest.push_back(44);
    long long t1, t2, t3;
    t1 = getTime();
    // gettimeofday(&t1,NULL);
    
    for (size_t i = 0; i < oht_num; i++) {
        head = new oht::OhtHead;
        head->id = i;
        head->is_in = true;
        oht::Oht<8,256> *tmp_oht;
        if (test_small) {
            // fprintf(stdout, "small %d %d \n", small_b, small_z);
            tmp_oht = new oht::Oht<8,256>(small_b, small_z);
            tmp_oht->bins1_.push_back(only_elem);
        } else {
            // fprintf(stdout, "big %d %d \n", small_b, small_z);
            tmp_oht = new oht::Oht<8,256>(big_b, big_z);
            tmp_oht->is_small = false;
            tmp_oht->bins1_.push_back(only_elem);
            tmp_oht->bins2_.push_back(only_elem);
        }
        head->size = 6120000;
        head->oht_p = tmp_oht;
        read_list.insertIntoSmallOht(head);
    }
    fprintf(stdout, "debug %d ohts\n", read_list.nextSmall());
    t2 = getTime();
    // gettimeofday(&t2,NULL);
    fprintf(stdout, "test_time_write %lld ms\n", (t2 - t1));
    for (auto it = read_list.begin(); it != read_list.end(); it = it->next) {
        oht::Oht<8,256> *oht;
        oht = it->oht_p;
        for (int a = 0; a < read_times; a++) {
            oht->lookup(only_elem, kPrfKey);
        }
        // fprintf(stdout, "de \n");
    }
    t3 = getTime();
    // gettimeofday(&t3,NULL);
    fprintf(stdout, "t3 %ld ms, t2 %lld ms\n", (long long)t3, (long long)t2);
    fprintf(stdout, "test_time_lookup %lld ms\n", (t3 - t2));

}

void enclave_helloworld()
{
    // Print a message from the enclave. Note that this
    // does not directly call fprintf, but calls into the
    // host and calls fprintf from there. This is because
    // the fprintf function is not part of the enclave
    // as it requires support from the kernel.
    // fprintf(stdout, "Hello world from the enclave\n");
    // for time
    // 
    // time_t t1;
    // time_t t2;
    // time(&t1);//获取现在的时间
    // time(&t2);//获取现在的时间
    // double seconds = difftime(t2,t1);
    // fprintf(stdout, "test_time %f\n", seconds);

    // Call back into the host
    // size_t oht_in_num = 32;
    // size_t read_times = 4502; 
    
    // // table 1
    // size_t N = 8388608;
    // size_t c = 5000;
    // size_t read_times = 5000; 
    // size_t batch_num = size_t(N / read_times);
    // size_t merage_trager = std::ceil(std::sqrt(batch_num));
    // size_t total_batch_num = batch_num;
    

    // small batch 改这个
    // 742,1446,2510, 3520, 4502
    size_t read_times = 4502; 
    size_t elems_num_batch = 4502;
    size_t total_batch_num = 1440; // 改这个
    size_t merage_trager = 38; // 改这个

    // // only big

    size_t num_big_oht = std::ceil(uint32_t(total_batch_num / merage_trager));
    size_t num_small_oht = merage_trager;

    size_t small_z = 25;
    size_t small_b = std::ceil(uint32_t(5* elems_num_batch / small_z));

    size_t big_z = 17;
    size_t big_b = std::ceil(uint32_t(5* elems_num_batch * merage_trager / big_z));

    bool test_small = false;
    ReadList<8,256> read_list;
    oht::OhtHead *head;
    oht::Elem<8, 256> only_elem;
    only_elem.tag = uint32_t(7);
    uint8_t array8[8];
    uint8_t array256[256];
    for (int i = 0; i < 8; ++i) {
        array8[i] = 8;
    }
    for (int i = 0; i < 8; ++i) {
        array256[i] = 256;
    }
    std::memcpy(only_elem.key, array8, 8);
    std::memcpy(only_elem.val, array256, 256);
    std::vector<uint8_t> kPrfKey{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    // std::vector<size_t> vTest{1,2,3};
    // vTest.push_back(44);
    long long t1, t2, t3;
    t1 = getTime();
    // gettimeofday(&t1,NULL);
    
    // for (size_t i = 0; i < oht_in_num; i++) {
    //     head = new oht::OhtHead;
    //     head->id = i;
    //     head->is_in = true;
    //     oht::Oht<8,256> *tmp_oht;
    //     if (test_small) {
    //         tmp_oht = new oht::Oht<8,256>(small_b, small_z);
    //         // for (size_t j = 0; j < 22500; j++) {
    //         //     tmp_oht->bins1_.push_back(only_elem);
    //         // }
    //         tmp_oht->bins1_.push_back(only_elem);
    //     } else {
    //         tmp_oht = new oht::Oht<8,256>(big_b, big_z);
    //         tmp_oht->is_small = false;
    //         // for (size_t j = 0; j < 225097; j++) {
    //         //     tmp_oht->bins1_.push_back(only_elem);
    //         //     tmp_oht->bins2_.push_back(only_elem);
    //         // }
    //         tmp_oht->bins1_.push_back(only_elem);
    //         tmp_oht->bins2_.push_back(only_elem);
    //     }

    //     // fprintf(stdout, "tmp_oht->size(): %d\n", tmp_oht->size()); 4502
    //     // fprintf(stdout, "tmp_oht->size(): %d\n", sizeof(*tmp_oht)); 没有意义
    //     // fprintf(stdout, "count： %d\n", i);
    //     head->size = 6120000;
    //     head->oht_p = tmp_oht;
    //     read_list.insertIntoSmallOht(head);
    // }

    // small_batch ------------------
    for (size_t i = 0; i < 2 * num_small_oht; i++) {
        head = new oht::OhtHead;
        head->id = i;
        head->is_in = true;
        oht::Oht<8,256> *tmp_oht;
        tmp_oht = new oht::Oht<8,256>(small_b, small_z);
        tmp_oht->is_small = true;
        tmp_oht->bins1_.push_back(only_elem);
        head->size = 6120000;
        head->oht_p = tmp_oht;
        read_list.insertIntoSmallOht(head);
    }
    for (size_t i = 0; i < num_big_oht; i++) {
        head = new oht::OhtHead;
        head->id = i;
        head->is_in = true;
        oht::Oht<8,256> *tmp_oht;
        tmp_oht = new oht::Oht<8,256>(big_b, big_z);
        tmp_oht->is_small = false;
        tmp_oht->bins1_.push_back(only_elem);
        tmp_oht->bins2_.push_back(only_elem);
        head->size = 6120000;
        head->oht_p = tmp_oht;
        read_list.insertIntoBigOht(head);
    }
    t2 = getTime();
    // gettimeofday(&t2,NULL);
    fprintf(stdout, "test_time_write %lld ms\n", (t2 - t1));
    for (auto it = read_list.begin(); it != read_list.end(); it = it->next) {
        oht::Oht<8,256> *oht;
        oht = it->oht_p;
        // fprintf(stdout, "debug \n");
        for (int a = 0; a < read_times; a++) {
            oht->lookup(only_elem, kPrfKey);
        }
        // fprintf(stdout, "de \n");
    }
    t3 = getTime();
    // gettimeofday(&t3,NULL);
    fprintf(stdout, "t3 %ld ms, t2 %lld ms\n", (long long)t3, (long long)t2);
    fprintf(stdout, "test_time_lookup %lld ms\n", (t3 - t2));
    // small_batch ----------------
    


    // oe_result_t result = host_helloworld();
    // if (result != OE_OK)
    // {
    //     fprintf(
    //         stderr,
    //         "Call to host_helloworld failed: result=%u (%s)\n",
    //         result,
    //         oe_result_str(result));
    // }
    // 3,651

}

static ReadList<8, 256> read_list;
static size_t configBatchNum = 4502;
static size_t configPktSize = sizeof(boomerang::Pkt);//288
static size_t configBigOhtSize = 122452768; //TODO
static size_t configSmallOhtSize = 6120000;




void enclave_helloworld1() {
    oht::OhtHead head;
    head.id = 1;
    read_list.insertIntoSmallOht(&head);
    fprintf(stdout, "configPktSize %d\n", configPktSize);
}

void er_testin(uint8_t* buffer, size_t buffer_size) {
    fprintf(stdout, "next %d\n", read_list.nextBig());
}

// void er_testout(uint)

void readSingle(oht::Elem<8,256> &elem) {
    std::vector<uint8_t> kPrfKey{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        // Oht* oht;
    for (auto it = read_list.begin(); it != read_list.end(); it = it->next) {
        oht::Oht<8,256> *oht;
        // 如果在内部，就在oht_in中找对应位置的oht   
        oht = it->oht_p;
        // 使用oht lookup
        oht->lookup(elem, kPrfKey);
    }
    return;    
    // 返回
}

void er_readBatch(uint8_t *dataBatch, size_t dataBatchSize) {
    fprintf(stdout, "er_readBatch\n");
    std::vector<oht::Elem<8,256>> elems{};
    elems.reserve(configBatchNum);
    std::vector<uint8_t> pkt_dec_buf{};
    pkt_dec_buf.reserve(configPktSize);
    int count = 0;
    for (auto pkt_start = dataBatch; pkt_start + configPktSize <= dataBatch + dataBatchSize; pkt_start += configPktSize) {
        count++;
        // fprintf(stdout, "er_readBatch_test: %d\n", count);
        elems.push_back(boomerang::pkt_const_buf_to_elem<8, 256>(pkt_start, pkt_dec_buf));
    }
    // 对每个elem调用
    for (auto& elem : elems) {
        readSingle(elem);
    }
    // 加密，转换为uint8_t
    for (auto i = 0; i < elems.size(); i++) {
        auto pkt_start = dataBatch + configPktSize * i;
        boomerang::val_elem_to_pkt<256>(pkt_start, elems[i].val);
    }
    // 返回
    return;

    
}

void ohtWrite(oht::Oht<8,256> *oht, std::vector<oht::Elem<8,256>> &&elems, const std::vector<uint8_t> &prf_key, unsigned jobs) {
    // fprintf(stdout, "ohtWrite\n");
    for (auto &&elem : elems) {
        oht->prepare(std::move(elem));
    }
    // fprintf(stdout, "ohtWrite\n");
    oht->build(prf_key, jobs);
    // fprintf(stdout, "ohtWrite\n");
    // todo 这个key到底是用来干啥的 fuck！！直接设置成全局一致了
    // ohtHead.prf_key = prf_key;
}

size_t er_writeBatch(uint8_t *dataBatch, size_t dataBatchSize) {
    // fprintf(stdout, "er_writeBatch\n");
    // 解密，转换为elems
    std::vector<oht::Elem<8, 256>> elems{};
    elems.reserve(configBatchNum);
    std::vector<uint8_t> pkt_dec_buf{};
    pkt_dec_buf.reserve(configPktSize);
    for (auto pkt_start = dataBatch; pkt_start + configPktSize <= dataBatch + dataBatchSize; pkt_start += configPktSize) {
        elems.push_back(boomerang::pkt_const_buf_to_elem<8, 256>(pkt_start, pkt_dec_buf));
    }
    // oht prepare build
    // 分配到堆上，避免被删除，注意自己删除
    size_t small_kb = 901;
    size_t small_kz = 25;
    auto ohtP = new oht::Oht<8,256>(small_kb, small_kz);
    ohtP->is_small = true;
    std::vector<uint8_t> kPrfKey{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    unsigned kJobs = 1;
    // fprintf(stdout, "er_writeBatch\n");
    ohtWrite(ohtP, std::move(elems), kPrfKey, kJobs);
    // 构造oht head 放进read_list
    auto ohtHead = new oht::OhtHead();
    // 注意，delete在exchange 和 退出函数中
    ohtHead->id = read_list.nextSmall();
    ohtHead->oht_p = ohtP;
    ohtHead->size = configSmallOhtSize;
    ohtHead->is_in = true;
    read_list.insertIntoSmallOht(ohtHead);
    // fprintf(stdout, "er_writeBatch\n");
    // 设置oht index
    // *index = ohtHead->id;
    // 返回
    return ohtHead->id;
}
void er_exchangeOht(size_t indexFrom, size_t indexTo, uint8_t *bigOhtHead, size_t bigOhtHeadSize) {
    fprintf(stdout, "er_writeBatch\n");
}


